<script type="text/javascript">
	// Initialize variables from Flask context
	let step = {{ step|tojson }};
	let step_size = {{ sec_per_step|tojson }} * 1000; // Convert to milliseconds
	let zoom = {{ zoom|tojson }};
	if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;

	let tile_width = 32;
	let movement_speed = {{ play_speed|tojson }};
	let execute_count_max = tile_width / movement_speed;
	let execute_count = execute_count_max;
	let all_movement = {{ all_movement|tojson }};

	let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
	let start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));

	// UI element variables (declared before use)
	let buttonPlay, buttonPause, buttonShowConversation, buttonHideConversation, buttonDetailConversation;
	let currentTime, textConversation;

	// Persona related variables
	let persona_names = {{ persona_init_pos|tojson }};
	var spawn_tile_loc = {};
	for (var key in persona_names) {
		spawn_tile_loc[key] = persona_names[key];
	}

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	let movement_target = {};

	let finished = false;
	let paused = false;
	let slider_dragging = false;
	let manual_time_change = false;
	let conversation_bubbles = [];  // Store conversation bubble sprites
	let show_conversations = true;  // Toggle for showing conversation bubbles
	let last_conversation_text = "";  // Track last conversation to avoid unnecessary updates
	let conversation_display_timer = 0;  // Timer to control bubble updates

	// Calculate total steps from all_movement data (excluding special keys)
	let total_steps = 0;
	for (let key in all_movement) {
		if (key !== "description" && key !== "conversation" && !isNaN(parseInt(key))) {
			total_steps = Math.max(total_steps, parseInt(key));
		}
	}

	// Phaser configuration
	const config = {
		type: Phaser.AUTO,
		// width: 4480,
		// height: 3200,
        width: document.documentElement.clientWidth / zoom,
        height: document.documentElement.clientHeight / zoom,
		parent: "game-container",
        mode: Phaser.Scale.FIT,
		pixelArt: true,
		physics: {
			default: "arcade",
			arcade: {
				gravity: { y: 0 }
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		},
		scale: {
			zoom: zoom
		}
	};

	// Create Phaser game instance
	const game = new Phaser.Game(config);
	let cursors;
	let player;

	// Preload function
	function preload() {
		this.load.crossOrigin = "";

		// Load images
		this.load.image("blocks_1", "static/assets/village/tilemap/blocks_1.png");
		this.load.image("walls", "static/assets/village/tilemap/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "static/assets/village/tilemap/interiors_pt1.png");
		this.load.image("interiors_pt2", "static/assets/village/tilemap/interiors_pt2.png");
		this.load.image("interiors_pt3", "static/assets/village/tilemap/interiors_pt3.png");
		this.load.image("interiors_pt4", "static/assets/village/tilemap/interiors_pt4.png");
		this.load.image("interiors_pt5", "static/assets/village/tilemap/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "static/assets/village/tilemap/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "static/assets/village/tilemap/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "static/assets/village/tilemap/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "static/assets/village/tilemap/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "static/assets/village/tilemap/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "static/assets/village/tilemap/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "static/assets/village/tilemap/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "static/assets/village/tilemap/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "static/assets/village/tilemap/CuteRPG_Forest_C.png");

		// Load tilemap JSON
		this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap.json");

		this.load.atlas("atlas", "static/assets/village/agents/いずみ/texture.png", filename="static/assets/village/agents/sprite.json");

		// Load persona atlases
		for (var p in persona_names) {
			image_static = "static/assets/village/agents/" + p + "/texture.png";
			this.load.atlas(p, image_static, filename="static/assets/village/agents/sprite.json");
		}
	}

	// Create function
	function create() {
		const map = this.make.tilemap({ key: "map" });

		// Add tilesets and layers
		const collisions = map.addTilesetImage("blocks", "blocks_1");
		const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
		const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
		const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
		const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
		const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
		const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
		const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
		const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
		const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
		const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
		const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
		const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
		const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
		const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
		const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

		let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B,
			CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
			interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];
		const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
		const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
		const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
		const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
		const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
		const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
		const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
		const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
		const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
		const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);

		const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);

		collisionsLayer.setCollisionByProperty({ collide: true });

		collisionsLayer.setDepth(-1);
		foregroundL1Layer.setDepth(2);
		foregroundL2Layer.setDepth(2);

		const canvas = game.canvas;
		canvas.addEventListener("wheel", (event) => {
			event.stopPropagation();
		}, { passive: false, capture: true });

		function add_text(game, x, y, text, background) {
			res = game.add.text(
				x,
				y,
				text,
				{
					font: "24px serif",
					fontWeight: "normal",
					fill: "#000000",
					backgroundColor: background,
					padding: { x: 20, y: 4},
					align: "left",
					wordWrap: { width: 1200/zoom, useAdvancedWrap: true },
				}
			);

			res.setDepth(20);  // Higher depth than conversation bubbles (14-15)
			res.alpha = 0.9;  // Slightly more visible
			res.setScrollFactor(0);

			return res;
		}

		posX = 20;
		posY = 20;

		// Add button: play, pause ...
		buttonPlay = add_text(this, posX, posY, "[実行]", "#ffffcc");
		buttonPlay.setInteractive();
		posX += buttonPlay.width + 10;

		buttonPause = add_text(this, posX, posY, " 一時停止 ", "#ffffcc");
		buttonPause.setInteractive();
		posX += buttonPause.width + 10;

		buttonShowConversation = add_text(this, posX, posY, "[対話表示]", "#ffffcc");
		buttonShowConversation.setInteractive();
		posX += buttonShowConversation.width + 10;

		buttonHideConversation = add_text(this, posX, posY, " 対話非表示 ", "#ffffcc");
		buttonHideConversation.setInteractive();
		posX += buttonHideConversation.width + 10;
		
		buttonDetailConversation = add_text(this, posX, posY, " 詳細表示 ", "#ffffcc");
		buttonDetailConversation.setInteractive();
		posX += buttonDetailConversation.width + 10;

		// Show current time
		currentTime = add_text(this, posX, posY, "", "#ccffcc");

		// Add time slider container
		let sliderContainer = document.createElement('div');
		sliderContainer.id = 'time-slider-container';
		sliderContainer.style.cssText = `
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 1000;
			background-color: rgba(204, 255, 204, 0.9);
			padding: 10px;
			border-radius: 5px;
			font-family: serif;
			font-size: 14px;
			border: 2px solid #99cc99;
		`;
		
		let sliderLabel = document.createElement('div');
		sliderLabel.textContent = '時間:';
		sliderLabel.style.marginBottom = '5px';
		
		let sliderWrapper = document.createElement('div');
		sliderWrapper.style.display = 'flex';
		sliderWrapper.style.alignItems = 'center';
		sliderWrapper.style.gap = '10px';
		
		let timeSlider = document.createElement('input');
		timeSlider.type = 'range';
		timeSlider.id = 'time-slider';
		timeSlider.min = '1';
		timeSlider.max = total_steps.toString();
		timeSlider.value = step.toString();
		timeSlider.style.width = '300px';
		
		let stepDisplay = document.createElement('span');
		stepDisplay.id = 'step-display';
		stepDisplay.textContent = `${step}/${total_steps}`;
		stepDisplay.style.minWidth = '80px';
		stepDisplay.style.fontSize = '12px';
		
		sliderWrapper.appendChild(timeSlider);
		sliderWrapper.appendChild(stepDisplay);
		sliderContainer.appendChild(sliderLabel);
		sliderContainer.appendChild(sliderWrapper);
		
		document.body.appendChild(sliderContainer);

		// Show conversation content  
		textConversation = add_text(this, 20, posY + currentTime.height + 10, " —— ", "#ccffcc");
		textConversation.setVisible(false);  // Initially hide large conversation box

		// Setup camera
		player = this.physics.add.sprite(2440, 500, "atlas", "down").setSize(30, 40).setOffset(0, 0);
		player.setDepth(-1);
		const camera = this.cameras.main;
		camera.startFollow(player);
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		cursors = this.input.keyboard.createCursorKeys();

		// Setup personas
		// We start by creating the game sprite objects.
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			let new_sprite = this.physics.add.sprite(start_pos[0], start_pos[1], persona_name, "down").setSize(30, 40).setOffset(0, 0);
			// Scale up the sprite
			new_sprite.displayWidth = 40;
			new_sprite.scaleY = new_sprite.scaleX;

			// Here, we are creating the persona and its pronunciatio sprites.
			personas[persona_name] = new_sprite;
			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - 15,
				new_sprite.body.y - 15 - 25,
				"",
				{
					font: "18px monospace",
					fill: "#000000",
					backgroundColor: "#ffffcc",
					padding: { x: 4, y: 4},
					border:"solid",
					borderRadius:"10px"
				}
			).setDepth(3);
			pronunciatios[persona_name].alpha = 0.7;
		}

		// Create animations
		const anims = this.anims;
		for (let i = 0; i < Object.keys(persona_names).length; i++) {
			let persona_name = Object.keys(persona_names)[i];
			let left_walk_name = persona_name + "-left-walk";
			let right_walk_name = persona_name + "-right-walk";
			let down_walk_name = persona_name + "-down-walk";
			let up_walk_name = persona_name + "-up-walk";

			frameRate = 4;
			if (movement_speed > 1) frameRate = 8;

			anims.create({
				key: left_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "left-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: right_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "right-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: down_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "down-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: up_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "up-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});
		}

		// Time slider event handlers
		timeSlider.addEventListener('input', function(e) {
			slider_dragging = true;
			let newStep = parseInt(e.target.value);
			updateStepDisplay(newStep);
		});

		timeSlider.addEventListener('change', function(e) {
			let newStep = parseInt(e.target.value);
			jumpToStep(newStep);
			slider_dragging = false;
		});

		// Function to update step display
		function updateStepDisplay(currentStep) {
			document.getElementById('step-display').textContent = `${currentStep}/${total_steps}`;
		}

		// Function to jump to specific step
		function jumpToStep(newStep) {
			if (newStep < 1 || newStep > total_steps) return;
			
			manual_time_change = true;
			step = newStep;
			execute_count = execute_count_max;
			
			// Update time based on step
			let stepDifference = newStep - {{ step|tojson }};
			start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));
			start_datetime.setTime(start_datetime.getTime() + (stepDifference * step_size));
			
			// Reset agent positions to the new step
			updateAgentPositions(newStep);
			updateConversationDisplay(newStep);
			updateStepDisplay(newStep);
			
			manual_time_change = false;
		}

		// Function to update agent positions for a specific step
		function updateAgentPositions(targetStep) {
			if (!(targetStep in all_movement)) return;
			
			for (let persona_name in personas) {
				let cleanName = persona_name.replace("_", " ");
				if (cleanName in all_movement[targetStep]) {
					let curr_x = all_movement[targetStep][cleanName]["movement"][0];
					let curr_y = all_movement[targetStep][cleanName]["movement"][1];
					let action = all_movement[targetStep][cleanName]["action"];
					
					// Update sprite position
					personas[persona_name].body.x = curr_x * tile_width;
					personas[persona_name].body.y = curr_y * tile_width;
					movement_target[persona_name] = [curr_x * tile_width, curr_y * tile_width];
					
					// Update action display
					let act = action;
					act = act.length > 25 ? act.substring(0, 20)+"..." : act;
					pronunciatios[persona_name].setText(persona_name + ": " + act);
					pronunciatios[persona_name].x = personas[persona_name].body.x - 15;
					pronunciatios[persona_name].y = personas[persona_name].body.y - 15 - 25;
					
					// Update status info
					document.getElementById("agent_desc__"+persona_name).innerHTML = all_movement["description"][persona_name]["currently"];
					document.getElementById("current_action__"+persona_name).innerHTML = action;
					document.getElementById("target_address__"+persona_name).innerHTML = all_movement[targetStep][cleanName]["location"];
				}
			}
		}

		// Function to update conversation display for a specific step
		function updateConversationDisplay(targetStep) {
			let curr_datetime = new Date(start_datetime.getTime());
			let curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
			let curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
			let curr_day = curr_datetime.getDate().toString().padStart(2, "0");
			let curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
			let curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");
			let conversation_key = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;
			
			let conversation_key_text = all_movement["conversation"][conversation_key];
			if (conversation_key_text && conversation_key_text != "") {
				textConversation.setText(`\n${conversation_key} 対話記録：\n` + conversation_key_text);
				
				// Update small conversation bubbles
				updateConversationBubbles(conversation_key_text);
			} else {
				// Clear conversation bubbles if no conversation and timer expired
				updateConversationBubbles(""); // Pass empty string to handle timer
			}
		}
		
		// Function to parse conversation text and extract participants
		function parseConversations(conversationText) {
			let conversations = [];
			let lines = conversationText.split('\n');
			let currentConv = null;
			
			for (let line of lines) {
				if (line.startsWith('場所：')) {
					if (currentConv) {
						conversations.push(currentConv);
					}
					currentConv = {
						location: line.replace('場所：', '').trim(),
						participants: [],
						messages: []
					};
				} else if (line.includes('：') && currentConv) {
					let [speaker, message] = line.split('：');
					speaker = speaker.trim();
					message = message.trim();
					
					if (speaker && message) {
						if (!currentConv.participants.includes(speaker)) {
							currentConv.participants.push(speaker);
						}
						currentConv.messages.push({speaker, message});
						
						// Keep only last 3 messages for bubble display
						if (currentConv.messages.length > 3) {
							currentConv.messages.shift();
						}
					}
				}
			}
			
			if (currentConv) {
				conversations.push(currentConv);
			}
			
			return conversations;
		}
		
		// Function to clear all conversation bubbles
		function clearConversationBubbles() {
			for (let bubble of conversation_bubbles) {
				if (bubble && bubble.destroy) {
					bubble.destroy();
				}
			}
			conversation_bubbles = [];
		}
		
		// Function to update conversation bubbles
		function updateConversationBubbles(conversationText) {
			// Clear existing bubbles
			clearConversationBubbles();
			
			if (!show_conversations) return;
			
			// Parse conversations
			let conversations = parseConversations(conversationText);
			
			// Create bubble for each conversation (max 3)
			for (let i = 0; i < Math.min(conversations.length, 3); i++) {
				let conv = conversations[i];
				
				// Calculate center position of participants
				let centerX = 0, centerY = 0;
				let validParticipants = 0;
				
				for (let participant of conv.participants) {
					if (personas[participant]) {
						centerX += personas[participant].body.x;
						centerY += personas[participant].body.y;
						validParticipants++;
					}
				}
				
				if (validParticipants > 0) {
					centerX /= validParticipants;
					centerY /= validParticipants;
					
					// Create bubble content
					let bubbleText = `📍${conv.location}\n`;
					for (let msg of conv.messages) {
						let displayMsg = msg.message;
						if (displayMsg.length > 20) {
							displayMsg = displayMsg.substring(0, 18) + '...';
						}
						bubbleText += `${msg.speaker}: ${displayMsg}\n`;
					}
					
					// Create bubble sprite
					let bubble = game.scene.scenes[0].add.text(
						centerX,
						centerY - 80 - (i * 100), // Offset for multiple bubbles
						bubbleText.trim(),
						{
							font: "12px monospace",
							fill: "#333333",
							backgroundColor: "rgba(255, 255, 255, 0.95)",
							padding: { x: 8, y: 6 },
							wordWrap: { width: 250, useAdvancedWrap: true },
							align: "left",
							stroke: "#cccccc",
							strokeThickness: 1,
						}
					);
					
					bubble.setDepth(4);
					bubble.setOrigin(0.5, 1);
					bubble.setShadow(2, 2, 'rgba(0,0,0,0.2)', 4);
					
					conversation_bubbles.push(bubble);
				}
			}
		}
	}

	// Update function
	function update(time, delta) {
		// Setup play and pause button
		buttonPlay.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = "[実行]";
			buttonPause.text = " 一時停止 ";
			paused = false;
		});

		buttonPause.on("pointerdown", function() {
			if (finished) return;
			buttonPlay.text = " 実行 ";
			buttonPause.text = "[一時停止]";
			paused = true;
		});

		buttonShowConversation.on("pointerdown", function() {
			buttonShowConversation.text = "[対話表示]";
			buttonHideConversation.text = " 対話非表示 ";
			show_conversations = true;
			textConversation.setVisible(false);  // Hide large text box, show bubbles
			// Re-update conversation bubbles
			if (conversation_key_text && conversation_key_text != "") {
				updateConversationBubbles(conversation_key_text);
			}
		});

		buttonHideConversation.on("pointerdown", function() {
			buttonShowConversation.text = " 対話表示 ";
			buttonHideConversation.text = "[対話非表示]";
			buttonDetailConversation.text = " 詳細表示 ";
			show_conversations = false;
			textConversation.setVisible(false);
			clearConversationBubbles();
		});
		
		buttonDetailConversation.on("pointerdown", function() {
			buttonShowConversation.text = " 対話表示 ";
			buttonHideConversation.text = " 対話非表示 ";
			buttonDetailConversation.text = "[詳細表示]";
			show_conversations = false;
			clearConversationBubbles();
			textConversation.setVisible(true);  // Show large text box
		});

		// Move camera
		const camera_speed = 400;
		player.body.setVelocity(0);
		if (cursors.left.isDown) {
			player.body.setVelocityX(-camera_speed);
		}
		if (cursors.right.isDown) {
			player.body.setVelocityX(camera_speed);
		}
		if (cursors.up.isDown) {
			player.body.setVelocityY(-camera_speed);
		}
		if (cursors.down.isDown) {
			player.body.setVelocityY(camera_speed);
		}

		let curr_focused_persona = document.getElementById("temp_focus").textContent;
		if (curr_focused_persona != "") {
			player.body.x = personas[curr_focused_persona].body.x;
			player.body.y = personas[curr_focused_persona].body.y;
			document.getElementById("temp_focus").innerHTML = "";
		}

		if (finished || paused || slider_dragging) {
			return;
		}

		// Update slider position during automatic playback (not manual changes)
		if (!manual_time_change) {
			let timeSlider = document.getElementById('time-slider');
			if (timeSlider) {
				timeSlider.value = step;
				document.getElementById('step-display').textContent = `${step}/${total_steps}`;
			}
		}

		curr_datetime = new Date(start_datetime.getTime());
		curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
		curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
		curr_day = curr_datetime.getDate().toString().padStart(2, "0");
		curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
		curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");
		conversation_key = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;
		conversation_key_text = all_movement["conversation"][conversation_key];
		if (conversation_key_text && conversation_key_text != "") {
			textConversation.setText(`\n${conversation_key} 対話記録：\n` + conversation_key_text);
			// Update small conversation bubbles
			updateConversationBubbles(conversation_key_text);
		} else {
			// Clear conversation bubbles if no conversation and timer expired
			updateConversationBubbles(""); // Pass empty string to handle timer
		}

		// Moving personas
		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[Object.keys(personas)[i]];

			if (step in all_movement) {
				if (curr_persona_name.replace("_", " ") in all_movement[step]) {
					if (execute_count == execute_count_max) {
						let curr_x = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][0];
						let curr_y = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][1];
						movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

						let action = all_movement[step][curr_persona_name.replace("_", " ")]["action"];

						let act = action;
						act = act.length > 25 ? act.substring(0, 20)+"..." : act;
						pronunciatios[curr_persona_name].setText(curr_persona_name + ": " + act);

						// Updating the status of each personas
						document.getElementById("agent_desc__"+curr_persona_name).innerHTML = all_movement["description"][curr_persona_name]["currently"];
						document.getElementById("current_action__"+curr_persona_name).innerHTML = action;
						document.getElementById("target_address__"+curr_persona_name).innerHTML = all_movement[step][curr_persona_name.replace("_", " ")]["location"];
					}

					if (execute_count > 0) {
						if (curr_persona.body.x < movement_target[curr_persona_name][0]) {
							curr_persona.body.x += movement_speed;
							anims_direction = "r";
							pre_anims_direction = "r";
							pre_anims_direction_dict[curr_persona_name] = "r";
						} else if (curr_persona.body.x > movement_target[curr_persona_name][0]) {
							curr_persona.body.x -= movement_speed;
							anims_direction = "l";
							pre_anims_direction = "l";
							pre_anims_direction_dict[curr_persona_name] = "l";
						} else if (curr_persona.body.y < movement_target[curr_persona_name][1]) {
							curr_persona.body.y += movement_speed;
							anims_direction = "d";
							pre_anims_direction = "d";
							pre_anims_direction_dict[curr_persona_name] = "d";
						} else if (curr_persona.body.y > movement_target[curr_persona_name][1]) {
							curr_persona.body.y -= movement_speed;
							anims_direction = "u";
							pre_anims_direction = "u";
							pre_anims_direction_dict[curr_persona_name] = "u";
						} else {
							anims_direction = "";
						}

						curr_pronunciatio.x = curr_persona.body.x - 15;
						curr_pronunciatio.y = curr_persona.body.y - 15 - 25;

						let left_walk_name = curr_persona_name + "-left-walk";
						let right_walk_name = curr_persona_name + "-right-walk";
						let down_walk_name = curr_persona_name + "-down-walk";
						let up_walk_name = curr_persona_name + "-up-walk";

						if (anims_direction == "l") {
							curr_persona.anims.play(left_walk_name, true);
						} else if (anims_direction == "r") {
							curr_persona.anims.play(right_walk_name, true);
						} else if (anims_direction == "u") {
							curr_persona.anims.play(up_walk_name, true);
						} else if (anims_direction == "d") {
							curr_persona.anims.play(down_walk_name, true);
						}
					}
				}
			} else {
				if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture(curr_persona_name, "left");
				else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture(curr_persona_name, "right");
				else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture(curr_persona_name, "up");
				else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture(curr_persona_name, "down");
				curr_persona.anims.stop();

				finished = true;
				buttonPlay.text = "[再生終了]";
				buttonPause.setVisible(false);
			}
		}

		if (execute_count == 0) {
			for (let i = 0; i < Object.keys(personas).length; i++) {
				let curr_persona_name = Object.keys(personas)[i];
				let curr_persona = personas[curr_persona_name];
				curr_persona.body.x = movement_target[curr_persona_name][0];
				curr_persona.body.y = movement_target[curr_persona_name][1];
			}
			execute_count = execute_count_max + 1;
			step = step + 1;

			start_datetime = new Date(start_datetime.getTime() + step_size);
			currentTime.setText(start_datetime.toLocaleTimeString("ja-JP", datetime_options));
		}

		execute_count -= 1;
	}

	// Parse conversation text to extract conversations
	function parseConversations(conversationText) {
		if (!conversationText || conversationText.trim() === "") return [];
		
		let conversations = [];
		let lines = conversationText.split('\n');
		let currentConv = null;
		
		for (let line of lines) {
			line = line.trim();
			if (line.startsWith('場所：')) {
				if (currentConv) {
					conversations.push(currentConv);
				}
				currentConv = {
					location: line.replace('場所：', ''),
					participants: [],
					messages: []
				};
			} else if (line.includes('：') && currentConv) {
				let parts = line.split('：');
				let speaker = parts[0].trim();
				let message = parts.slice(1).join('：').trim();
				
				if (!currentConv.participants.includes(speaker)) {
					currentConv.participants.push(speaker);
				}
				currentConv.messages.push({speaker: speaker, message: message});
			}
		}
		
		if (currentConv) {
			conversations.push(currentConv);
		}
		
		return conversations;
	}

	// Clear all conversation bubble sprites
	function clearConversationBubbles() {
		for (let bubble of conversation_bubbles) {
			if (bubble && bubble.destroy) {
				bubble.destroy();
			}
		}
		conversation_bubbles = [];
	}

	// Update conversation bubbles display
	function updateConversationBubbles(conversationText) {
		// If same conversation and timer hasn't expired, keep current bubbles
		if (conversationText === last_conversation_text && conversation_display_timer > 0) {
			conversation_display_timer--;
			return; // Keep existing bubbles, don't recreate
		}
		
		// If empty conversation text but timer still active, keep bubbles
		if (!conversationText && conversation_display_timer > 0) {
			conversation_display_timer--;
			return; // Keep existing bubbles
		}
		
		// Update timer and conversation text for new conversations
		if (conversationText !== last_conversation_text) {
			conversation_display_timer = conversationText ? 500 : 0; // Only set timer for non-empty conversations
			last_conversation_text = conversationText;
		}
		
		// Only clear and recreate bubbles for new conversations or when timer expires
		clearConversationBubbles();
		
		if (!show_conversations) return;
		
		// Parse conversations
		let conversations = parseConversations(conversationText);
		
		// Create bubble for each conversation (max 3)
		for (let i = 0; i < Math.min(conversations.length, 3); i++) {
			let conv = conversations[i];
			
			// Calculate center position of participants
			let centerX = 0, centerY = 0;
			let validParticipants = 0;
			
			for (let participant of conv.participants) {
				if (personas[participant]) {
					centerX += personas[participant].body.x;
					centerY += personas[participant].body.y;
					validParticipants++;
				}
			}
			if (validParticipants > 0) {
				centerX = (centerX / validParticipants) + 16; // Offset to center of sprite
				centerY = (centerY / validParticipants) - 60; // Above the sprites
				
				// Create conversation bubble text
				// Split location by comma and show only last 2 parts
				let locationParts = conv.location.split('，');
				let shortLocation = locationParts.slice(-2).join('，');
				let bubbleText = `${shortLocation}\n`; // Location on first line
				
				// Calculate the maximum line length for dynamic width
				let maxLineLength = shortLocation.length;
				for (let msg of conv.messages.slice(0, 2)) { // Show max 2 messages
					let shortMsg = msg.message.length > 60 ? msg.message.substring(0, 60) + "..." : msg.message;
					let lineText = `${msg.speaker}：${shortMsg}`;
					bubbleText += `${lineText}\n`; // Speaker and message on same line
					maxLineLength = Math.max(maxLineLength, lineText.length);
				}
				
				// Calculate dynamic width based on text length (approximately 30px per character for 18px font)
				let dynamicWidth = Math.max(400, maxLineLength * 30);
				
				// Debug output
				console.log("Bubble Debug:");
				console.log("- bubbleText:", bubbleText);
				console.log("- maxLineLength:", maxLineLength);
				console.log("- dynamicWidth:", dynamicWidth);
				
				// Create background rectangle first
				let background = game.scene.scenes[0].add.graphics();
				background.fillStyle(0xffffcc, 0.9); // Light yellow background
				background.fillRoundedRect(centerX - dynamicWidth/2, centerY - 50, dynamicWidth, 100, 8);
				background.setDepth(14);
				background.setScrollFactor(1);
				
				// Create text without background
				let textObj = game.scene.scenes[0].add.text(
					centerX, centerY, bubbleText,
					{
						font: "18px serif",
						fill: "#000000",
						align: "left",
						wordWrap: { width: dynamicWidth - 24, useAdvancedWrap: false }
					}
				);
				
				textObj.setOrigin(0.5, 0.5); // Center the text
				textObj.setDepth(15);
				textObj.setScrollFactor(1);
				
				// Debug actual sizes
				console.log("- background width:", dynamicWidth);
				console.log("- text width:", textObj.width);
				console.log("- text displayWidth:", textObj.displayWidth);
				
				conversation_bubbles.push(background);
				conversation_bubbles.push(textObj);
			}
		}
	}
</script>
